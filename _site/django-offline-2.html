<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
	<meta name="generator" content="Jekyll">

	<title>Adding Service Workers to your Django App (part 2/3)</title>
  <meta name="description" content="Learn how to add service workers to the polls app from the official django tutorial.">

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/css/main.css">

	<!-- RSS -->
	<link href="/atom.xml" type="application/atom+xml" rel="alternate" title="ATOM Feed" />

  <!-- Favicon -->
  <link rel="shortcut icon" type="image/png" href="img/favicon.ico">

</head>


<body>
	<div id="wrap">
	  	
	  	<!-- Navigation -->
	  	<nav id="nav">
	<div id="nav-list">
		<a href="/">Home</a>

		<!-- Nav pages -->
	  
	    
	  
	    
	      <a href="/about" title="About">About</a>
	    
	  
	    
	  
	    
	      <a href="/autism" title="Autism">Autism</a>
	    
	  
	    
	      <a href="/deutsch" title="Deutsch">Deutsch</a>
	    
	  
	    
	      <a href="/diy" title="DIY">DIY</a>
	    
	  
	    
	  
	    
	  
	    
	      <a href="/programming" title="Code">Code</a>
	    
	  
	    
	      <a href="/travel" title="Travel">Travel</a>
	    
	  
	    
	  
	    
	  
	    
	  
    
    <!-- Nav links -->
	  

	</div>
  
  <!-- Nav footer -->
	
	  <footer>

	<span>version 1.0.0</span>

</footer>

	

</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>

      <!-- Header -->
      
        <header id="header" class="parent justify-spaceBetween">
  <div class="inner w100 relative">
    <span class="f-left">
      <a href="/">
        <div id="brand">
          aspi<span>girl</span>codes
        </div>
      </a>
    </span>
    <span id="nav-links" class="absolute right bottom">
      <!-- Nav pages -->
      
      
	      
	    
	      
	        <a href="/about" title="About">About</a>
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	    
	      
	        <a href="/autism" title="Autism">Autism</a>
	      
	    
	      
	        <a href="/programming" title="Code">Code</a>
	      
	    
	      
	        <a href="/diy" title="DIY">DIY</a>
	      
	    
	      
	        <a href="/travel" title="Travel">Travel</a>
	      
	    
	      
	        <a href="/deutsch" title="Deutsch">Deutsch</a>
	      
	    

      <!-- Nav links -->
	    

    </span>
  </div>
</header>

      

    <!-- Main content -->
	  <div id="container">
		  
		<main>

			<article id="post-page">
	<h1>Adding Service Workers to your Django App (part 2/3)</h1>
	<time datetime="2018-03-24T00:00:00+01:00" class="by-line">24 Mar 2018</time>
	<div class="content">

		<p>This is part 2 of a 3-part tutorial about adding service workers to a django web-app. In this part we will register our first service worker and use it to display an offline page.</p>

<ul>
  <li>This is part 2: an offline page using a service worker.</li>
  <li><a href="/django-offline-1">part 1: preparation and setup</a></li>
  <li><a href="/django-offline-3">part 3: implementing a caching strategy</a></li>
</ul>

<h2 id="registering-your-first-service-worker">Registering Your First Service Worker</h2>

<p>The service worker logic will live in a separate JavaScript file called
<code class="highlighter-rouge">serviceworker.js</code>. The location of this file as seen by the browser is important for the
scope the service worker will have. The maximum scope of the service
worker is limited by the fact that it can only control files that are
below the <code class="highlighter-rouge">serviceworker.js</code> file in the URL path hierarchy.</p>

<p>JavaScript files are static
files and are traditionally served under the <code class="highlighter-rouge">/static</code> path in your Django
project. However if you would serve your file on the path, the scope
would also be limited to <code class="highlighter-rouge">/static</code>, and there is not a single HTML page there.
Therefore, the easiest way to serve your <code class="highlighter-rouge">serviceworker.js</code> file is by using a Django view.</p>

<p>In this project, you can put this view in the polls app. It will then be
served under <code class="highlighter-rouge">/polls/serviceworker.js</code> and its scope will be the polls apps custom views.</p>

<p>In a
real project you might want to serve your service worker in the
namespace without URL prefix. It will then be served at <code class="highlighter-rouge">/serviceworker.js</code> and will have
your whole project as its scope instead of just one app.</p>

<p>Alternatively,
you can also have several service workers, each with their own scopes.
Scopes should not overlap though, as in that case only the most specific
service worker will apply (and the newest one if they have exactly the
same scope).</p>

<p>To serve the serviceworker as a view, first create a new view in your polls app’s <code class="highlighter-rouge">views.py</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">...</span>

<span class="k">class</span> <span class="nc">ServiceWorker</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">TemplateView</span><span class="p">):</span>
    <span class="n">template_name</span> <span class="o">=</span> <span class="s">"polls/serviceworker.js"</span>
    <span class="n">content_type</span> <span class="o">=</span> <span class="s">"application/JavaScript"</span></code></pre></figure>

<p>Then add the the URL to the polls app’s <code class="highlighter-rouge">urls.py</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">...</span>

<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">...</span>
    <span class="n">url</span><span class="p">(</span><span class="s">r'^serviceworker.js$'</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">ServiceWorker</span><span class="o">.</span><span class="n">as_view</span><span class="p">())</span>
<span class="p">]</span></code></pre></figure>

<p>Finally, add the service worker itself. Create <code class="highlighter-rouge">polls/templates/polls/serviceworker.js</code> and add the following
content to it:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">"fetch"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Fetch request for:"</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">url</span><span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>This is a simple service worker that listens to fetch events, and logs
them.</p>

<p>You now have created a service worker and Django is serving it at <code class="highlighter-rouge">/polls/serviceworker.js</code>. But you have not told the browser yet that you want to register the
file at <code class="highlighter-rouge">/polls/serviceworker.js</code> as a service worker. This should be done from inside a
JavaScript script in a page the user is visiting.</p>

<p>So you will have to
add another JavaScript file containing the service worker registration
and include it in your templates. As this file is just a normal
JavaScript file loaded directly in the page, and not a service worker
you can add it to the static files.</p>

<p>Create a file called <code class="highlighter-rouge">app.js</code> in <code class="highlighter-rouge">polls/static/polls</code>, and add
the following content to it:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="k">if</span> <span class="p">(</span><span class="s2">"serviceWorker"</span> <span class="k">in</span> <span class="nx">navigator</span><span class="p">){</span> <span class="c1">// Check if browser supports service workers</span>
  <span class="nx">navigator</span><span class="p">.</span><span class="nx">serviceWorker</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s2">"/polls/serviceworker.js"</span><span class="p">)</span>
  <span class="c1">//register returns a promise</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">registration</span><span class="p">){</span> <span class="c1">// if promise resolved</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Service Worker registered with scope:"</span><span class="p">,</span> <span class="nx">registration</span><span class="p">.</span><span class="nx">scope</span><span class="p">);</span>
    <span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">){</span> <span class="c1">// if promise rejected</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"Service worker registration failed:"</span><span class="p">,</span> <span class="nx">err</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span></code></pre></figure>

<p>Then add the following line to the scripts block in your <code class="highlighter-rouge">base.html</code> file:</p>

<figure class="highlight"><pre><code class="language-htmldjango" data-lang="htmldjango">...
{% block scripts %}
  &lt;script src="{% static 'polls/app.js' %}"&gt;&lt;/script&gt;
{% endblock scripts %}
...</code></pre></figure>

<p>If you now run your Django development server (<code class="highlighter-rouge">python manage.py runserver</code>), and visit one of the
pages from your polls app, for example <code class="highlighter-rouge">localhost:8000/polls/</code>, your
service worker will be registered.</p>

<p>You can check this by looking at the
browser logs using the developer tools of your browser. When you
subsequently click around within the polls app by opening questions and
casting votes, you should see that each request is logged by your
service worker.</p>

<blockquote>
  <p><strong>Note:</strong> If you do not have any questions in your local database yet,
use your superuser credential to go to the Django admin and create
some.</p>
</blockquote>

<h2 id="letting-your-service-worker-serve-an-offline-html-page">Letting Your Service Worker Serve an Offline HTML Page</h2>

<p>Now that you have registered your service worker, you are now ready to use it for serving a customized offline page to your users.</p>

<p>First,
create an offline page in your polls app. To do this, you need to make
the following changes:</p>

<p>Add a new file called <code class="highlighter-rouge">offline.html</code> in <code class="highlighter-rouge">polls/templates/polls</code>:</p>

<figure class="highlight"><pre><code class="language-htmldjango" data-lang="htmldjango">{% extends "polls/base.html" %}

{% block title %} Polls {% endblock title %}

{% block content %}
  &lt;h1&gt;You are offline&lt;/h1&gt;
  &lt;p&gt;
    We are sorry that you are experiencing connectivity issues
    and hope you come back soon to share your opinion with our polls.
  &lt;/p&gt;
{% endblock content %}
{% block scripts %}
{% endblock %}</code></pre></figure>

<p>Add code for the offline view to <code class="highlighter-rouge">polls/views.py</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">...</span>
<span class="k">class</span> <span class="nc">OfflineView</span><span class="p">(</span><span class="n">generic</span><span class="o">.</span><span class="n">TemplateView</span><span class="p">):</span>
    <span class="n">template_name</span> <span class="o">=</span> <span class="s">"polls/offline.html"</span></code></pre></figure>

<p>And add the URL to <code class="highlighter-rouge">polls/urls.py</code>:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="o">...</span>
<span class="n">urlpatterns</span> <span class="o">=</span> <span class="p">[</span>
    <span class="o">...</span>
    <span class="n">url</span><span class="p">(</span><span class="s">r'^offline/$'</span><span class="p">,</span> <span class="n">views</span><span class="o">.</span><span class="n">OfflineView</span><span class="o">.</span><span class="n">as_view</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="s">"offline"</span><span class="p">)</span>
<span class="p">]</span></code></pre></figure>

<p>Next, in order to be able to show the user this custom offline page that
you have defined on your server, you will first have to store it in the
users browser. A good time to do this is when installing your service
worker. This way you can be sure that this page is available in the
cache when your service worker becomes active after installation.</p>

<p>Remove
the existing code from your <code class="highlighter-rouge">serviceworker.js</code> file and instead add the following:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">"install"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">waitUntil</span><span class="p">(</span><span class="c1">// dont' let install event finish until this succeeds</span>
    <span class="nx">caches</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">"polls-cache"</span><span class="p">)</span><span class="c1">// open new or existing cache, returns a promise</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">cache</span><span class="p">){</span><span class="c1">// if cache-opening promise resolves</span>
        <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="s2">"/polls/offline/"</span><span class="p">)</span><span class="c1">// add offline page</span>
    <span class="p">})</span>
  <span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>This adds an event listener for the install event. The install event
happens after the registration and before the activation of your service
worker. (In the next section I will explain the service worker life cycle and
which events happen when in more detail.)</p>

<p>You want the install event
to succeed only when it manages to cache the offline page. If not the
install event should fail, and reattempted later. This is achieved by
using <code class="highlighter-rouge">event.waitUntil(function)</code>. The function passed to <code class="highlighter-rouge">waitUntil</code> should return a promise. Only if this
promise resolves will the install event be allowed to end.</p>

<p><code class="highlighter-rouge">caches.open</code> either opens
an existing cache with the name you pass on to it, or, if no cache with
this name exists, it creates a new one. The opened cache is returned in
a promise. So after this promise resolves, we can be sure to have a
usable cache instance, and add our offline page to it. Resources are
stored in the cache with their path as a key. Old entries with the same
key will be overwritten.</p>

<p>Now that you have put your offline page in the
cache, you can retrieve it when fetching content from the server fails.
To do this, add the following to your <code class="highlighter-rouge">serviceworker.js</code> file:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">"fetch"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span><span class="c1">// answer the request with ...</span>
    <span class="nx">fetch</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">)</span> <span class="c1">// try to fetch from server</span>
      <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="c1">// if this is rejected</span>
        <span class="k">return</span> <span class="nx">caches</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="s2">"/polls/offline/"</span><span class="p">)</span> <span class="c1">// return offline page from cache</span>
      <span class="p">})</span>
  <span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<blockquote>
  <p><strong>Note:</strong> The promise that is returned by caches.match always
resolves, even if no match was found. In this case this does not
really matter. We know we loaded the page during the install phase,
and if for some reason it would not be there anymore, we would not be
able to get it from the server anyway as we already know we are
offline. In other situations you might want to check for it though:</p>

  <pre><code class="language-JavaScript">    caches.match("request/path").then(function(response){
      if (response){
        return response;
      }
    });
    
</code></pre>
</blockquote>

<p>Testing the new service worker is easiest when you delete the old one
manually.</p>

<p>In Firefox first go to the list of service workers by typing <code class="highlighter-rouge">about:debugging\#workers</code>
in your address bar or by choosing <code class="highlighter-rouge">WebDeveloper&gt;ServiceWorker</code> from the menu.</p>

<p>In Chrome the list of
service workers can be found under <code class="highlighter-rouge">chrome://serviceworker-internals.</code>. Then click unregister next to your
<code class="highlighter-rouge">localhost:8000/polls</code> service worker.</p>

<p>Another way to make sure the
service worker gets replaced is by closing all the tabs related to the
polls app, and waiting until the service worker stops running. Only now,
open a polls page in a new tab again for the register event to be
triggered and installing the new service worker version. The following
section on service worker life cycle will help you understand better as
to why this is necessary.</p>

<p>Then run your Django development server (<code class="highlighter-rouge">python manage.py runserver</code>) and
visit the page to let your new service worker install. In the shell
where you are running the Django server, you should see that a get
request for the <code class="highlighter-rouge">/polls/offline/page</code> is made. Then quit the development server (<code class="highlighter-rouge">ctrl-c</code>) and reload
the page in your browser. You should now see your custom offline page.</p>

<h2 id="intermezzo-service-worker-life-cycle">Intermezzo: Service Worker Life Cycle</h2>

<p>What makes service workers slightly more complicated than normal
JavaScript run in a webpage is the fact that they are not bound to a
single page they can live and die with. They can control multiple pages
in different browser windows or tabs, and can even react to certain
events without needing any open tab or window at all.</p>

<p>To handle this
complexity correctly service workers have well defined life cycles with
different states. You have already encountered the installation state,
triggered by registering the service worker, and the active state, in
which the service worker can listen to fetch events. But installed does
not necessarily mean active. Before a newly installed service worker can
become active, the browser needs to make sure that the old one is done
with its work. So as long as there are pages controlled by the old
service worker open, the new one will have to stay in the waiting state.</p>

<p><img src="sw-lifecycle" alt="Service worker’s life cycle&lt;span
data-label=&quot;fig:sw-lifecycle&quot;&gt;&lt;/span&gt;" />{width=”80.00000%”}</p>

<p>Figure [fig:sw-lifecycle] shows a diagram of the service worker life
cycle.</p>

<p>The first state is the <strong>installing</strong> state. It is triggered by
the register function, but only if the service worker that is asking to
be registered is different from the currently active one. So you can be
sure that one and the same service worker is only installed once, even
if the register logic is hit multiple times. You can add your own logic
to the installing phase by listening to the “install” event and using
waitUntil() to keep the service worker in that state until your logic
either succeeds or fails. If it fails, your service worker will go to
the redundant state. Only when the register function is called again
(for example by refreshing the page) will their be another install event
and another chance to get your service worker active.</p>

<p>After successfull
installation, the service worker comes in a <strong>waiting</strong> state. If no
active service worker is for the same scope is detected, it can move
straight on to the next state. If there is an active service worker
however, it has to wait here, until the active service worker is no
longer controlling any pages and can be turned of and moved to the
redundant state.</p>

<blockquote>
  <p><strong>Note:</strong> Refreshing a page is not enough to make a service worker
redundant and start using a new one. During refresh, the service
worker will remain in control. The only way to stop it is to navigate
to a page outside of its scope, or to close the tab it is controlling.</p>
</blockquote>

<p>The service worker now enters the <strong>activating</strong> state. This is the
place where you can do things that have to be done before the new
service worker becomes active that might have a negative impact on an
old service worker that might have been still running during the
installing phase. To add such logic to your service worker listen to the
“activate” event. Again you can use waitUntil() to avoid that the
service worker moves on to the active state already and starts receiving
fetch events.</p>

<p>After the activating process has finished, the service
worker moves to the <strong>active</strong> state. In this state it can react to
various events such as “fetch”, “sync”, “push” and “message”.</p>

<p>The final
state of the service worker is <strong>redundant</strong>. Service workers will land
in this state when registration (for example: the specified service
worker path does not exist) or installation (the promise passed to the
“install” events waitUntil method rejects) fail. Or when they are
replaced by a new service worker.</p>

<h2 id="caching-multiple-assets-and-cleaning-up-old-caches">Caching Multiple Assets and Cleaning up Old Caches</h2>

<p>You might have noticed that the poll’s background image is not loaded as
part of your offline page. That is because you have only cached the HTML
page and not the additional assets such as CSS files and images. You
will have to make to more changes to the <code class="highlighter-rouge">serviceworker.js</code> file to change this.</p>

<p>First
change the install event logic in <code class="highlighter-rouge">serviceworker.js</code> like so:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">CACHE_NAME</span> <span class="o">=</span> <span class="s2">"polls-cache-v2"</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">CACHED_URLS</span> <span class="o">=</span> <span class="p">[</span>
  <span class="s2">"/polls/offline/"</span><span class="p">,</span>
  <span class="s2">"/static/polls/style.css"</span><span class="p">,</span>
  <span class="s2">"/static/polls/images/background.png"</span>
<span class="p">]</span>

<span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">"install"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">waitUntil</span><span class="p">(</span><span class="c1">// dont' let install event finish until this succeeds</span>
    <span class="nx">caches</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="nx">CACHE_NAME</span><span class="p">)</span><span class="c1">// open new or existing cache, returns a promise</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">cache</span><span class="p">){</span><span class="c1">// if cache-opening promise resolves</span>
        <span class="k">return</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">addAll</span><span class="p">(</span><span class="nx">CACHED_URLS</span><span class="p">)</span><span class="c1">// add CACHED_URLS</span>
    <span class="p">})</span>
  <span class="p">);</span>
<span class="p">});</span>
<span class="p">...</span></code></pre></figure>

<p>Instead of <code class="highlighter-rouge">cache.add</code> the service worker now uses <code class="highlighter-rouge">cache.addAll</code> to add a list of URLs to the
cache.</p>

<p>Second, you have to update the fetch event logic to return the
cached assets, and not just the offline HTML page, as it is doing now.
This can be done as follows:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="p">...</span>
<span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">"fetch"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">respondWith</span><span class="p">(</span><span class="c1">// answer the request with ...</span>
    <span class="nx">fetch</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">)</span> <span class="c1">// try to fetch from server</span>
      <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span> <span class="c1">// if this is rejected</span>
        <span class="k">return</span> <span class="nx">caches</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">)</span> <span class="c1">// try to return from cache</span>
          <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">response</span><span class="p">){</span> <span class="c1">// caches.match allways resolves</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// check if something was found in cache</span>
              <span class="k">return</span> <span class="nx">response</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span>
              <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="nx">request</span><span class="p">.</span><span class="nx">headers</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s2">"accept"</span><span class="p">).</span><span class="nx">includes</span><span class="p">(</span><span class="s2">"text/html"</span><span class="p">)){</span>
              <span class="c1">// requesting a html file and not finding a match in cache</span>
              <span class="k">return</span> <span class="nx">caches</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="s2">"/polls/offline/"</span><span class="p">)</span>
            <span class="p">}</span>
          <span class="p">});</span>
      <span class="p">})</span>
  <span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>To test, remove the old service worker manually using the developer
tools. Then run your Django development server(<code class="highlighter-rouge">python manage.py runserver</code>), and load a polls app
page to register and install the new service worker. Quit the Django
development server and reload the page in your browser. Does your
offline page now have the background image?</p>

<p>Two questions remain to be
answered. Why did I tell you to change the cache name by adding a v2
tag to it? And, as a new cache was created instead of using the old one,
what happens to the old caches?</p>

<p>There are a couple of reasons for
versioning your cache. First, while the browser does detect changes to
the <code class="highlighter-rouge">serviceworker.js</code> file automatically and reinstalls it, if we would make changes to
any of the cached assets, this will not be seen by the browser. By
changing the cache name each time you change something, you can make
sure a new service worker is installed and your cached assets are
updated. On top of that, the new assets will be downloaded in a new
cache. This is good, because caching is done during the installation
phase. This means the old service worker, that might rely on the old
assets, is still active.</p>

<blockquote>
  <p><strong>Note:</strong> While it is considered good practice to version your cache
by changing the cache name with each version, you should try not to
change your service worker URL as this can cause unwanted side
effects. For example, suppose you have an active that is active and
caches rigorously. If you would change it to , you would then also
have to change the argument of the register function, which might be
part of the cached assets. How are you ever going to get this update
live? It is better to keep the service worker URL the same, and let
the browser take care of updating your service worker when something
has changed.</p>
</blockquote>

<p>You do, however, need to take care of deleting old caches. Browser
storage is limited, and although the actual limits vary based on various
circumstances, it is a good habit to clean up after yourself from the
start. Cleaning up the cache is typically done in the activation phase
of the service worker life cycle, as at this point you can be sure that
the old service worker is no longer needing it.</p>

<p>Add the following code
to your <code class="highlighter-rouge">serviceworker.js</code> file:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">self</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">"activate"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">){</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">waitUntil</span><span class="p">(</span> <span class="c1">// do not finish activation until this succeeds</span>
    <span class="nx">caches</span><span class="p">.</span><span class="nx">keys</span><span class="p">()</span> <span class="c1">// a promise containing an array of all cache names</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">cacheNames</span><span class="p">){</span>
        <span class="k">return</span> <span class="nx">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span>
        <span class="c1">// return a promise that only succeeds</span>
        <span class="c1">// if all of the promises in the array succeed</span>
          <span class="nx">cacheNames</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">cacheName</span><span class="p">){</span>
          <span class="c1">// to create an array of promises, map the array of cachenames</span>
            <span class="c1">// for each of them:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">CACHE_NAME</span> <span class="o">!==</span> <span class="nx">cacheName</span> <span class="p">){</span>
            <span class="c1">// if name is not the same as current caches name</span>
              <span class="k">return</span> <span class="nx">caches</span><span class="p">.</span><span class="k">delete</span><span class="p">(</span><span class="nx">cacheName</span><span class="p">);</span>
              <span class="c1">// delete it and succeeds after that</span>
            <span class="p">};</span>
          <span class="p">})</span>
        <span class="p">);</span>
      <span class="p">})</span>
  <span class="p">);</span>
<span class="p">});</span></code></pre></figure>

<p>This code listens to the “activate” event. It first gets an array of
cache names. This array is then transformed to an array of promises, one
for each cache we want to delete, succeeding exactly then when the cache
is deleted. This array is passed to <code class="highlighter-rouge">Promise.all()</code>, which only succeeds if all
elements of the array succeed.</p>

<blockquote>
  <p><strong>Note:</strong> Depending on your application you might need a more
complicated if clause. For example if you are using the cache storage
at other places in your app, or if you use multiple caches at once.</p>
</blockquote>

<p>You have now enhanced your Django web app with a custom offline page
using a service worker. That is nice, but you can do more than that with
service workers. In the next section you will implement a more complete
caching strategy.</p>

<ul>
  <li>This was part 2: an offline page using a service worker.</li>
  <li><a href="/django-offline-1">part 1: preparation and setup</a></li>
  <li><a href="/django-offline-3">part 3: implementing a caching strategy</a></li>
</ul>


	</div>
	<p>
		Categories: 
		
  		<a href="/programming">Programming</a>
  		
  	
	</p>
</article>


	  </main>
		
		  <!-- Pagination links -->
      

	  </div>
	    
	    <!-- Footer -->
	    <footer>
  <span><a href="https://www.twitter.com/aspigirlcodes">@aspigirlcodes</a></span>
  <br/>
  <span>Built with Jekyll and the Monochrome theme</span>
</footer>


	    <!-- Script -->
      <script src="/js/main.js"></script>	


	</div>
</body>
</html>
